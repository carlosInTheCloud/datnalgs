package search

import (
	"fmt"
	"sort"
)

func Print() {
	fmt.Println("just so it doesn't complain about importing fmt")
}

// Given an unsorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(n)
func LinearUnsortedSearch(v []int, d int) bool {
	for _, x := range v {
		if x == d {
			return true
		}
	}
	return false
}

// Given an sorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(n)
func LinearSortedSearch(v []int, d int) bool {
	for _, x := range v {
		if x == d {
			return true
		}
		if x > d {
			return false
		}
	}
	return false
}

// Given an sorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(log n)
func BynarySearch(v []int, d int) bool {
	s := len(v)
	l := 0
	u := s - 1

	for l < u {
		i := (l + u) / 2
		if v[i] > d {
			u = i - 1
		} else if v[i] < d {
			l = i + 1
		} else {
			return true
		}
	}
	return false
}
// Given an sorted array, return true if d exists
// in the array, false otherwise. Use the fibonacci algorithm.
// worst time complexity: O(log n)
func FibonacciSearch(v []int, d int) bool {
	s := len(v) - 1
	f := 1
	f1 := 1
	f2 := 0

	for f < s {
		f2 = f1
		f1 = f
		f = f1 + f2
	}
	l := 0
	for f > 1 {
		i := min(f2+l, s-1)
		if v[i] == d {
			return true
		} else if v[i] < d {
			f = f1
			f1 = f2
			f2 = f - f1
			l = i
		} else {
			f = f2
			f1 = f1 - f2
			f2 = f - f1
		}
	}
	if v[f2+l] == d {
		return true
	}

	return false
}

// Write a metod that will return the sum of all the integer
// array elements given array as an input argument
func SumArrayItems(v []int) int {
	t := 0
	for _, x := range v {
		t += x
	}
	return t
}

// given an usorted list of n elements,
// find teh first element which is repeated
// without sorting the array.
func FirstRepeated(v []int) int {
	s := len(v)
	hm := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := hm[v[i]]
		if exists {
			hm[v[i]] = hm[v[i]] + 1
		} else {
			hm[v[i]] = 1
		}
	}
	for k, x := range hm {
		if x > 1 {
			return k
		}
	}
	return 0
}

// Given an array of n numbers,
// return the duplicate elements in the array
func FindDups(v []int) []int {
	s := len(v)
	m := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := m[v[i]]
		if exists {
			m[v[i]] = m[v[i]] + 1
		} else {
			m[v[i]] = 1
		}
	}
	dup := []int{}
	for k, v := range m {
		if v > 1 {
			dup = append(dup, k)
		}
	}
	return dup
}

// Given an array of n numbers,
// return the duplicate elements in the array
func FindDupsSorting(v []int) []int {
	sort.Ints(v)
	vd := []int{}
	s := len(v) - 1
	for i := 0; i < s; i++ {
		if v[i] == v[i+1] {
			vd = append(vd, v[i])
		}
	}
	return vd
}

// Remove Dups from Array.
// TC: O(n), SC: O(1)
func RemoveDups(data []int) []int {
	size := len(data)
	sort.Ints(data)
	j := 0
	for i := 1; i < size; i++ {
		if data[i] != data[j] {
			j++
			data[j] = data[i]
		}
	}
	return data[:j+1]
}

// Remove Dups without Sorting
// TC: O(n), SC: O(n)
func RemoveDupsMap(v []int) []int {
	s := len(v)
	m := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := m[v[i]]
		if exists {
			m[v[i]] = m[v[i]] + 1
		} else {
			m[v[i]] = 1
		}
	}
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// Given an array with values that start at 1, find the missing number.
// TC: O(n.log(n)), SC: O(n) if using merge sort.
func FindMissingNumber(v []int) (int, bool) {
	s := len(v)
	mergeSort(v)
	for i := 0; i < s; i++ {
		if v[i] != i+1 {
			return i + 1, true
		}
	}
	return 0, false
}

func mergeSort(v []int) {
	s := len(v)
	vt := make([]int, s)
	mergeDivide(v, vt, 0, s-1)
}

func mergeDivide(v, vt []int, l, u int) {
	if l >= u {
		return
	}
	m := (l + u) / 2
	mergeDivide(v, vt, l, m)
	mergeDivide(v, vt, m+1, u)
	mergeConquer(v, vt, l, m, u)
}
func mergeConquer(v, vt []int, l, m, u int) {
	ls := l
	us := m + 1
	c := l

	for ls <= m && us <= u {
		if v[ls] <= v[us] {
			vt[c] = v[ls]
			ls++
		} else {
			vt[c] = v[us]
			us++
		}
		c++
	}
	for ls <= m {
		vt[c] = v[ls]
		ls++
		c++
	}
	for us <= u {
		vt[c] = v[us]
		us++
		c++
	}
	for i := l; i <= u; i++ {
		v[i] = vt[i]
	}
}

// find missing number using a map.
// TC: O(n), SC: O(n)
func FindMissingNumberMap(v []int) (int, bool) {
	m := make(map[int]int)
	for _, x := range v {
		m[x] = 1
	}
	s := len(v)
	for i := 1; i <= s; i++ {
		_, ok := m[i]
		if !ok {

			return i, true
		}
	}
	return 0, false
}
