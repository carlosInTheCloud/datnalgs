package search

// Given an unsorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(n)
func LinearUnsortedSearch(v []int, d int) bool {
	for _, x := range v {
		if x == d {
			return true
		}
	}
	return false
}

// Given an sorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(n)
func LinearSortedSearch(v []int, d int) bool {
	for _, x := range v {
		if x == d {
			return true
		}
		if x > d {
			return false
		}
	}
	return false
}

// Given an sorted array, return true if d exists
// in the array, false otherwise.
// worst time complexity: O(log n)
func BynarySearch(v []int, d int) bool {
	s := len(v)
	l := 0
	u := s - 1
	for l < u {
		i := (l + u) / 2
		if v[i] > d {
			u = i - 1
		} else if v[i] < d {
			l = i + 1
		} else {
			return true
		}
	}
	return false
}

// Given an sorted array, return true if d exists
// in the array, false otherwise. Use the fibonacci algorithm.
// worst time complexity: O(log n)
func FibonacciSearch(v []int, d int) bool {
	s := len(v)
	f1 := 1
	f2 := 0
	f := f1 + f2
	for f < s {
		f2 = f1
		f1 = f
		f = f1 + f2
	}
	l := 0
	for f > 1 {
		i := min(l+f2, s-1)
		if v[i] == d {
			return true
		} else if v[i] < d {
			f = f1
			f1 = f2
			f2 = f - f1
			l = i
		} else {
			f = f2
			f1 = f1 - f2
			f2 = f - f1
		}
	}
	if v[l+f2] == d {
		return true
	}
	return false
}
// Write a metod that will return the sum of all the integer
// array elements given array as an input argument
func SumArrayItems(v []int) int {
	t := 0
	for _, x := range v {
		t += x
	}
	return t
}
// given an usorted list of n elements,
// find teh first element which is repeated
// without sorting the array.
func firstrepeated(v []int) int {
	s := len(v)
	hm := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := hm[v[i]]
		if exists {
			hm[v[i]] = hm[v[i]] + 1
		} else {
			hm[v[i]] = 1
		}
	}
	for k, v := range hm {
		if v > 1 {
			return k
		}
	}
	return 0
}

// Given an array of n numbers,
// return the duplicate elements in the array
func FindDups(v []int) []int {
	s := len(v)
	m := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := m[v[i]]
		if exists {
			m[v[i]] = m[v[i]] + 1
		} else {
			m[v[i]] = 1
		}
	}
	dup := []int{}
	for k, v := range m {
		if v > 1 {
			dup = append(dup, k)
		}
	}
	return dup
}

// Given an array of n numbers,
// return the duplicate elements in the array
func FindDupsSorting(v []int) []int {
	sort.Ints(v)
	vd := []int{}
	s := len(v) - 1
	for i := 0; i < s; i++ {
		if v[i] == v[i+1] {
			vd = append(vd, v[i])
		}
	}
	return vd
}

// Remove Dups from Array.
// TC: O(n), SC: O(1)
func RemoveDups(data []int) []int {
	size := len(data)
	sort.Ints(data)
	j := 0
	for i := 1; i < size; i++ {
		if data[i] != data[j] {
			j++
			data[j] = data[i]
		}
	}
	return data[:j+1]
}

// Remove Dups without Sorting
// TC: O(n), SC: O(n)
func RemoveDupsMap(v []int) []int {
	s := len(v)
	m := make(map[int]int)
	for i := 0; i < s; i++ {
		_, exists := m[v[i]]
		if exists {
			m[v[i]] = m[v[i]] + 1
		} else {
			m[v[i]] = 1
		}
	}
	keys := make([]int, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}
